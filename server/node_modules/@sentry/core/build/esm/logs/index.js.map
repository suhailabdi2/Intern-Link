{"version":3,"file":"index.js","sources":["../../../src/logs/index.ts"],"sourcesContent":["import type { Client } from '../client';\nimport { _getTraceInfoFromScope } from '../client';\nimport { getClient, getCurrentScope } from '../currentScopes';\nimport { DEBUG_BUILD } from '../debug-build';\nimport { SEVERITY_TEXT_TO_SEVERITY_NUMBER } from './constants';\nimport type { SerializedLogAttribute, SerializedOtelLog } from '../types-hoist';\nimport type { Log } from '../types-hoist/log';\nimport { logger } from '../utils-hoist';\nimport { _getSpanForScope } from '../utils/spanOnScope';\nimport { createOtelLogEnvelope } from './envelope';\n\nconst MAX_LOG_BUFFER_SIZE = 100;\n\nconst CLIENT_TO_LOG_BUFFER_MAP = new WeakMap<Client, Array<SerializedOtelLog>>();\n\n/**\n * Converts a log attribute to a serialized log attribute.\n *\n * @param key - The key of the log attribute.\n * @param value - The value of the log attribute.\n * @returns The serialized log attribute.\n */\nexport function logAttributeToSerializedLogAttribute(key: string, value: unknown): SerializedLogAttribute {\n  switch (typeof value) {\n    case 'number':\n      return {\n        key,\n        value: { doubleValue: value },\n      };\n    case 'boolean':\n      return {\n        key,\n        value: { boolValue: value },\n      };\n    case 'string':\n      return {\n        key,\n        value: { stringValue: value },\n      };\n    default: {\n      let stringValue = '';\n      try {\n        stringValue = JSON.stringify(value) ?? '';\n      } catch (_) {\n        // Do nothing\n      }\n      return {\n        key,\n        value: { stringValue },\n      };\n    }\n  }\n}\n\n/**\n * Captures a log event and sends it to Sentry.\n *\n * @param log - The log event to capture.\n * @param scope - A scope. Uses the current scope if not provided.\n * @param client - A client. Uses the current client if not provided.\n *\n * @experimental This method will experience breaking changes. This is not yet part of\n * the stable Sentry SDK API and can be changed or removed without warning.\n */\nexport function _INTERNAL_captureLog(log: Log, client = getClient(), scope = getCurrentScope()): void {\n  if (!client) {\n    DEBUG_BUILD && logger.warn('No client available to capture log.');\n    return;\n  }\n\n  const { _experiments, release, environment } = client.getOptions();\n  if (!_experiments?.enableLogs) {\n    DEBUG_BUILD && logger.warn('logging option not enabled, log will not be captured.');\n    return;\n  }\n\n  const [, traceContext] = _getTraceInfoFromScope(client, scope);\n\n  const { level, message, attributes, severityNumber } = log;\n\n  const logAttributes = {\n    ...attributes,\n  };\n\n  if (release) {\n    logAttributes.release = release;\n  }\n\n  if (environment) {\n    logAttributes.environment = environment;\n  }\n\n  const span = _getSpanForScope(scope);\n  if (span) {\n    // Add the parent span ID to the log attributes for trace context\n    logAttributes['sentry.trace.parent_span_id'] = span.spanContext().spanId;\n  }\n\n  const serializedLog: SerializedOtelLog = {\n    severityText: level,\n    body: {\n      stringValue: message,\n    },\n    attributes: Object.entries(logAttributes).map(([key, value]) => logAttributeToSerializedLogAttribute(key, value)),\n    timeUnixNano: `${new Date().getTime().toString()}000000`,\n    traceId: traceContext?.trace_id,\n    severityNumber: severityNumber ?? SEVERITY_TEXT_TO_SEVERITY_NUMBER[level],\n  };\n\n  const logBuffer = CLIENT_TO_LOG_BUFFER_MAP.get(client);\n  if (logBuffer === undefined) {\n    CLIENT_TO_LOG_BUFFER_MAP.set(client, [serializedLog]);\n    // Every time we initialize a new log buffer, we start a new interval to flush the buffer\n    return;\n  }\n\n  logBuffer.push(serializedLog);\n  if (logBuffer.length > MAX_LOG_BUFFER_SIZE) {\n    _INTERNAL_flushLogsBuffer(client, logBuffer);\n  }\n}\n\n/**\n * Flushes the logs buffer to Sentry.\n *\n * @param client - A client.\n * @param maybeLogBuffer - A log buffer. Uses the log buffer for the given client if not provided.\n */\nexport function _INTERNAL_flushLogsBuffer(client: Client, maybeLogBuffer?: Array<SerializedOtelLog>): void {\n  const logBuffer = maybeLogBuffer ?? CLIENT_TO_LOG_BUFFER_MAP.get(client) ?? [];\n  if (logBuffer.length === 0) {\n    return;\n  }\n\n  const clientOptions = client.getOptions();\n  const envelope = createOtelLogEnvelope(logBuffer, clientOptions._metadata, clientOptions.tunnel, client.getDsn());\n\n  // Clear the log buffer after envelopes have been constructed.\n  logBuffer.length = 0;\n\n  // sendEnvelope should not throw\n  // eslint-disable-next-line @typescript-eslint/no-floating-promises\n  client.sendEnvelope(envelope);\n}\n\n/**\n * Returns the log buffer for a given client.\n *\n * Exported for testing purposes.\n *\n * @param client - The client to get the log buffer for.\n * @returns The log buffer for the given client.\n */\nexport function _INTERNAL_getLogBuffer(client: Client): Array<SerializedOtelLog> | undefined {\n  return CLIENT_TO_LOG_BUFFER_MAP.get(client);\n}\n"],"names":[],"mappings":"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"}